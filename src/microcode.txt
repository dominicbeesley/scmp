# MIT License
# -----------------------------------------------------------------------------
# Copyright (c) 2021 Dominic Beesley https://github.com/dominicbeesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# -----------------------------------------------------------------------------


# Microcode file for a SC/MP
#


# NEXTPC is usally a relative step to the next line. the microcode can jump 
# to other lines by setting this section attribute to a value other than 1
# a value of 'd0 is special and will alway force a jump to the first line of 
# micrcode
# NOTE: if a line of microcode is "skipped" due to a condition match then
# the NEXTPC value is ignored and the next microcode line is executed next.
SECTION:NEXTPC,SIGNED,8
	NEXT='d1*			# normal operation go to next line
	FETCH='d0			# go to microcode line 0 == FETCH




#MAKE SURE THE TWO FOLLOWING SECTIONS MATCH!
#SECTIONS COND_MASK and COND_XOR are applied to a set of bits 
#
#	assign cond_in = { op[7], op[2:0], c_jmp };
#
#	assign	c_jmp = 
#		(op[3:2] == 2'b01)?~neg:		//jp i.e. !neg
#		(op[3:2] == 2'b10)?zer:		//jz
#		(op[3:2] == 2'b11)?~zer:
#		1'b1;				//always jmp
#
#	assign cond =| ((cond_in ^ mcode.cond_xor) & mcode.cond_mask);
#
# If cond is true then then NEXTPC value on the current line is ignored
# and effectively replaced with 'd1

SECTION:COND_MASK,BITMAP,6
	NUL=NUL*
	OP2=		'b100000
	ADI=		'b011100			# ADI tests for immediate operations on bits 2:0 of the opcode	
	JMP=		'b000010
	POSTINC=	'b000001
SECTION:COND_XOR,BITMAP,6
	NUL=NUL*
	OP2=		'b000000
	ADI=		'b010000			# ADI tests for immediate operations on bits 2:0 of the opcode
	JMP=		'b000000
	POSTINC=	'b000001

SECTION:BUS,BITMAP,7
	NUL=NUL*
	WR
	RD
	ADS
	FLG_R
	FLG_I
	FLG_D
	FLG_H
	ADSOP=ADS|FLG_R|FLG_I
	ADSRD=ADS|FLG_R
	ADSWR=ADS


SECTION:LD_L,BITMAP,12
	NUL=NUL*			# Load nothing from low read bus
	P0				# Load P0 low from low read bus
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STAT
	D
	OP
	ST_ALU
	EA
	ADDR_PC=P0|ADDR
	D_ACC=D|ACC
	ACC_STAT_ALU=ACC|ST_ALU
	EA_ADDR=EA|ADDR
SECTION:LD_H,BITMAP,6
	NUL=NUL*
	P0
	P1
	P2
	P3
	ADDR
	EA
	ADDR_PC=P0|ADDR
	EA_ADDR=EA|ADDR
SECTION:RD_L,ONEHOT,10
	P0*
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STATUS
	D
	EA
SECTION:RD_H,ONEHOT,6
	P0*
	P1
	P2
	P3
	ADDR
	EA
SECTION:WR_L,ONEHOT,3
	RD_H
	RD_L*
	ALU
SECTION:WR_H,ONEHOT,3
	RD_H*
	RD_L
	INCR4
SECTION:ALU_OP,INDEX,4
	NUL='b0000*
	NUL1='b0001
	AND='b0010
	OR='b0011
	XOR='b0100
	DA='b0101
	ADD='b0110
	CAD='b0111
	SR='b1000
	SRL='b1001
	RR='b1010
	RRL='b1011
	INC='b1100	
	DEC='b1101
	ADD_NOCARRYIN='b1110

SECTION:CTL,BITMAP,4
	NUL=NUL*
	DECODE
	LOGICOP
	RET
	CALL

CODESTART=7

#NOTE: FETCH MUST be the first line!
RESET:
FETCH:
	LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
	BUS=ADSOP
	BUS=RD, LD_L=OP
	NEXTPC=@DECODE, COND_MASK=OP2, COND_XOR=OP2
	LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
	BUS=ADSRD
	BUS=RD, LD_L=D
DECODE:
#decode step will jump to the instruction see scmp_microcode_oppc.sv
	CTL=DECODE

# all loads lead to here and also all logical ops
LD:	
	
	NEXTPC=@LDI, COND_MASK=ADI, COND_XOR=ADI			# test for LDI
	NEXTPC=@EA, CTL=CALL
LDI:
	NEXTPC=FETCH, WR_L=ALU, RD_L=ACC, LD_L=ACC_STAT_ALU, CTL=LOGICOP

EA:
	NEXTPC=@EAPOSTINC1, COND_MASK=POSTINC, COND_XOR=POSTINC
	LD_L=EA_ADDR, LD_H=EA_ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	NEXTPC=NEXT									#DEAD CYCLE
EAREST:
	BUS=ADSRD
	BUS=RD, LD_L=D, CTL=RET
EAPOSTINC1:
	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=RD_L, WR_H=RD_H
	NEXTPC=@EAREST,LD_L=EA, LD_H=EA, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD

LDE:	
	NEXTPC=@LDI, RD_L=EXT, WR_L=RD_L, LD_L=D
ST:
	LD_L=EA, LD_H=EA, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSWR, WR_L=RD_L, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
DLD:
	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSRD
	BUS=RD, LD_L=D
	LD_L=D_ACC, WR_L=ALU, ALU_OP=DEC, RD_L=D
	BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
ILD:
	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSRD
	BUS=RD, LD_L=D
	LD_L=D_ACC, ALU_OP=INC, RD_L=D
	BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
JMP:	
	NEXTPC=FETCH, RD_L=ACC, COND_MASK=JMP, COND_XOR=JMP
	NEXTPC=FETCH, LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD_NOCARRYIN

XAE:	
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_L, LD_L=ACC, RD_L=EXT
	NEXTPC=FETCH, WR_L=RD_L, LD_L=EXT, RD_L=D
XPAL:
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_L, LD_L=ACC, RD_L=EA
	NEXTPC=FETCH, WR_L=RD_L, LD_L=EA, RD_L=D
XPAH:
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_H, LD_L=ACC, RD_H=EA
	NEXTPC=FETCH, WR_H=RD_L, LD_H=EA, RD_L=D



#TODO
# For PC-relative, indexed and auto-indexed memory reference instructions is that the contents of the extension register are # substituted for the displacement if the instruction displace equals -128!# 
# AUTO indexed
# AUTO indexed -ve before, +ve after!

