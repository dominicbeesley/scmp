# MIT License
# -----------------------------------------------------------------------------
# Copyright (c) 2021 Dominic Beesley https://github.com/dominicbeesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# -----------------------------------------------------------------------------


# Microcode file for a SC/MP
#


# NEXTPC is usally a relative step to the next line. the microcode can jump 
# to other lines by setting this section attribute to a value other than 1
# a value of 'd0 is special and will alway force a jump to the first line of 
# micrcode
# NOTE: if a line of microcode is "skipped" due to a condition match then
# the NEXTPC value is ignored and the next microcode line is executed next.
SECTION:NEXTPC,SIGNED,8
	NEXT='d1*			# normal operation go to next line
	FETCH='d0			# go to microcode line 0 == FETCH




#MAKE SURE THE TWO FOLLOWING SECTIONS MATCH!
#SECTIONS COND_MASK and COND_XOR are applied to a set of bits 
#
#	assign cond_in = { op[7], op[2:0], c_jmp };
#
#	assign	c_jmp = 
#		(op[3:2] == 2'b01)?~neg:		//jp i.e. !neg
#		(op[3:2] == 2'b10)?zer:		//jz
#		(op[3:2] == 2'b11)?~zer:
#		1'b1;				//always jmp
#
#	assign cond =| ((cond_in ^ mcode.cond_xor) & mcode.cond_mask);
#
# If cond is true then then NEXTPC value on the current line is ignored
# and effectively replaced with 'd1

SECTION:COND_MASK,BITMAP,8
	NUL=NUL*
	OP2=		'b1000000
	ADI=		'b0111000			# ADI tests for immediate operations on bits 2:0 of the opcode	
	JMP=		'b0000100
	POSTINC=	'b0000010
	RDL80=		'b0000001
SECTION:COND_XOR,BITMAP,7
	NUL=NUL*
	OP2=		'b0000000
	ADI=		'b0100000			# ADI tests for immediate operations on bits 2:0 of the opcode
	JMP=		'b0000000
	POSTINC=	'b0000010			# JUMP if POSTINC
	POSTINCNEG=	'b0000000			# JUMP if !POSTINC
	RDL80=		'b0000001			# JUMP IF RD_L=0x80

SECTION:BUS,BITMAP,7
	NUL=NUL*
	WR
	RD
	ADS
	FLG_R
	FLG_I
	FLG_D
	FLG_H
	ADSOP=ADS|FLG_R|FLG_I
	ADSRD=ADS|FLG_R
	ADSWR=ADS


SECTION:LD_L,BITMAP,14
	NUL=NUL*			# Load nothing from low read bus
	P0				# Load P0 low from low read bus
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STAT
	D
	D80				# Load D if D=0x80 (used in LD/ST)
	OP
	ST_ALU
	EA				# Load P0..3 depending on bits in op[1:0]
	EAM				# Load P0..3 depending on bits in op[1:0] only if op[2] == 'b1
	ADDR_PC=P0|ADDR
	D_ACC=D|ACC
	ACC_STAT_ALU=ACC|ST_ALU
	EAM_ADDR=EAM|ADDR
SECTION:LD_H,BITMAP,7
	NUL=NUL*
	P0
	P1
	P2
	P3
	ADDR
	EA				# Load P0..3 depending on bits in op[1:0]
	EAM				# Load P0..3 depending on bits in op[1:0] only if op[2] == 'b1
	ADDR_PC=P0|ADDR
	EAM_ADDR=EAM|ADDR
SECTION:RD_L,ONEHOT,10
	P0*
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STATUS
	D
	EA
SECTION:RD_H,ONEHOT,6
	P0*
	P1
	P2
	P3
	ADDR
	EA
SECTION:WR_L,ONEHOT,3
	RD_H
	RD_L*
	ALU
SECTION:WR_H,ONEHOT,3
	RD_H*
	RD_L
	INCR4
SECTION:ALU_OP,INDEX,4
	NUL='b0000*
	NUL1='b0001
	AND='b0010
	OR='b0011
	XOR='b0100
	DA='b0101
	ADD='b0110
	CAD='b0111
	SR='b1000
	SRL='b1001
	RR='b1010
	RRL='b1011
	INC='b1100	
	DEC='b1101
	ADD_NOCARRYIN='b1110

SECTION:CTL,BITMAP,4
	NUL=NUL*
	DECODE
	LOGICOP
	RET
	CALL

CODESTART=7

#NOTE: FETCH MUST be the first line!
RESET:
FETCH:		LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
		BUS=ADSOP
		BUS=RD, LD_L=OP
		NEXTPC=@DECODE, COND_MASK=OP2, COND_XOR=OP2
		LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
		BUS=ADSRD
		BUS=RD, LD_L=D
DECODE:
#decode step will jump to the instruction see scmp_microcode_oppc.sv
		CTL=DECODE

# all loads lead to here and also all logical ops
LD:		NEXTPC=@LDI, COND_MASK=ADI, COND_XOR=ADI			# test for LDI
		NEXTPC=@EA, CTL=CALL
		BUS=ADSRD
		BUS=RD, LD_L=D
LDI:		NEXTPC=FETCH, WR_L=ALU, RD_L=ACC, LD_L=ACC_STAT_ALU, CTL=LOGICOP


EA:		NEXTPC=@EAOFFSEXT,  RD_L=D, COND_MASK=RDL80, COND_XOR=RDL80				# if D=0x80 then replace with EXT
		NEXTPC=@EAPOSTINC1, RD_L=D, COND_MASK=POSTINC, COND_XOR=POSTINC				# if op[2]='1' and +ve displacement do POSTINC
EAR2:		LD_L=EAM_ADDR, LD_H=EAM_ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD	# set address and EA if op[2] set
		CTL=RET											# DEAD CYCLE to match postinc
		# offset was -128, replace with contents of EXT		
EAOFFSEXT:	NEXTPC=@EAR2, COND_MASK=POSTINC, COND_XOR=POSTINCNEG, RD_L=EXT, LD_L=D			# replace D with EXT
EAPOSTINC1:	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=RD_L, WR_H=RD_H				# set ADDR
		CTL=RET,LD_L=EA, LD_H=EA, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD	# update register separately

LDE:		NEXTPC=@LDI, RD_L=EXT, WR_L=RD_L, LD_L=D


ST:		NEXTPC=NEXT										# DEAD cycle
		NEXTPC=@EA, CTL=CALL
		BUS=ADSWR, WR_L=RD_L, LD_L=D, RD_L=ACC
		BUS=WR, NEXTPC=FETCH

DLD:
		NEXTPC=@EA, CTL=CALL
		BUS=ADSRD
		BUS=RD, LD_L=D
		LD_L=D_ACC, RD_L=D
		BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC, ALU_OP=DEC
		BUS=WR, NEXTPC=FETCH
ILD:
		NEXTPC=@EA, CTL=CALL
		BUS=ADSRD
		BUS=RD, LD_L=D
		LD_L=D_ACC, RD_L=D
		BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC, ALU_OP=INC
		BUS=WR, NEXTPC=FETCH
JMP:	
	NEXTPC=FETCH, RD_L=ACC, COND_MASK=JMP, COND_XOR=JMP
	NEXTPC=FETCH, LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD_NOCARRYIN

XAE:	
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_L, LD_L=ACC, RD_L=EXT
	NEXTPC=FETCH, WR_L=RD_L, LD_L=EXT, RD_L=D
XPAL:
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_L, LD_L=ACC, RD_L=EA
	NEXTPC=FETCH, WR_L=RD_L, LD_L=EA, RD_L=D
XPAH:
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_H, LD_L=ACC, RD_H=EA
	NEXTPC=FETCH, WR_H=RD_L, LD_H=EA, RD_L=D



#TODO
# For PC-relative, indexed and auto-indexed memory reference instructions is that the contents of the extension register are # substituted for the displacement if the instruction displace equals -128!# 
# AUTO indexed
# AUTO indexed -ve before, +ve after!

