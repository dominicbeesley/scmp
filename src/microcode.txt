# MIT License
# -----------------------------------------------------------------------------
# Copyright (c) 2021 Dominic Beesley https://github.com/dominicbeesley
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
# -----------------------------------------------------------------------------


# Microcode file for a SC/MP
#


# NEXTPC is usally 
SECTION:NEXTPC,SIGNED,8
	NEXT='d1*			# normal operation go to next line
	FETCH='d0			# go to microcode line 0 == FETCH




#MAKE SURE THE TWO FOLLOWING SECTIONS MATCH!
#SECTIONS COND_MASK and COND_XOR are applied to a set of bits 
#
#	assign cond_in = { op[7], op[2:0], c_jmp };
#
#	assign	c_jmp = 
#		(op[3:2] == 2'b01)?~neg:		//jp i.e. !neg
#		(op[3:2] == 2'b10)?zer:		//jz
#		(op[3:2] == 2'b11)?~zer:
#		1'b1;				//always jmp



SECTION:COND_MASK,BITMAP,5
	NUL=NUL*
	OP2='b10000
	ADI='b01110			# ADI tests for immediate operations on bits 2:0 of the opcode	
	JMP='b00001
SECTION:COND_XOR,BITMAP,5
	NUL=NUL*
	OP2='b00000
	ADI='b01000			# ADI tests for immediate operations on bits 2:0 of the opcode
	JMP='b00000


SECTION:BUS,BITMAP,7
	NUL=NUL*
	WR
	RD
	ADS
	FLG_R
	FLG_I
	FLG_D
	FLG_H
	ADSOP=ADS|FLG_R|FLG_I
	ADSRD=ADS|FLG_R
	ADSWR=ADS
SECTION:LD_L,BITMAP,12
	NUL=NUL*			# Load nothing from low read bus
	P0				# Load P0 low from low read bus
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STAT
	D
	OP
	ST_ALU
	EA
	ADDR_PC=P0|ADDR
	D_ACC=D|ACC
	ACC_STAT_ALU=ACC|ST_ALU
SECTION:LD_H,BITMAP,6
	NUL=NUL*
	P0
	P1
	P2
	P3
	ADDR
	EA
	ADDR_PC=P0|ADDR
SECTION:RD_L,ONEHOT,10
	P0*
	P1
	P2
	P3
	ADDR
	ACC
	EXT
	STATUS
	D
	EA
SECTION:RD_H,ONEHOT,6
	P0*
	P1
	P2
	P3
	ADDR
	EA
SECTION:WR_L,ONEHOT,3
	RD_H
	RD_L*
	ALU
SECTION:WR_H,ONEHOT,3
	RD_H*
	RD_L
	INCR4
SECTION:ALU_OP,INDEX,4
	NUL='b0000*
	NUL1='b0001
	AND='b0010
	OR='b0011
	XOR='b0100
	DA='b0101
	ADD='b0110
	CAD='b0111
	SR='b1000
	SRL='b1001
	RR='b1010
	RRL='b1011
	INC='b1100	
	DEC='b1101
	ADD_NOCARRYIN='b1110

SECTION:CTL,BITMAP,2
	NUL=NUL*
	DECODE
	LOGICOP

CODESTART=7

#NOTE: FETCH MUST be the first line!
RESET:
FETCH:
	LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
	BUS=ADSOP
	BUS=RD, LD_L=OP
	NEXTPC=@DECODE, COND_MASK=OP2, COND_XOR=OP2
	LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=P0, RD_H=P0, WR_L=ALU, WR_H=INCR4, ALU_OP=INC
	BUS=ADSRD
	BUS=RD, LD_L=D
DECODE:
#decode step will jump to the instruction see scmp_microcode_oppc.sv
	CTL=DECODE

# all loads lead to here and also all logical ops
LD:	
# test for LDI
	NEXTPC=@LDI, COND_MASK=ADI, COND_XOR=ADI
	LD_L=EA, LD_H=EA, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSRD
	BUS=RD, LD_L=D
LDI:
	NEXTPC=FETCH, WR_L=ALU, RD_L=ACC, LD_L=ACC_STAT_ALU, CTL=LOGICOP
LDE:	
	NEXTPC=@LDI, RD_L=EXT, WR_L=RD_L, LD_L=D
ST:
	LD_L=EA, LD_H=EA, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSWR, WR_L=RD_L, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
DLD:
	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSRD
	BUS=RD, LD_L=D
	LD_L=D_ACC, WR_L=ALU, ALU_OP=DEC, RD_L=D
	BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
ILD:
	LD_L=ADDR, LD_H=ADDR, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD
	BUS=ADSRD
	BUS=RD, LD_L=D
	LD_L=D_ACC, ALU_OP=INC, RD_L=D
	BUS=ADSWR, WR_L=ALU, LD_L=D, RD_L=ACC
	BUS=WR, NEXTPC=FETCH
JMP:	
	NEXTPC=FETCH, COND_MASK=JMP, COND_XOR=JMP
	NEXTPC=FETCH, LD_L=ADDR_PC, LD_H=ADDR_PC, RD_L=EA, RD_H=EA, WR_L=ALU, WR_H=INCR4, ALU_OP=ADD_NOCARRYIN
#TODO: check for timing
XAE:	
	WR_L=RD_L, LD_L=D, RD_L=ACC
	WR_L=RD_L, LD_L=ACC, RD_L=EXT
	NEXTPC=FETCH, WR_L=RD_L, LD_L=EXT, RD_L=D

